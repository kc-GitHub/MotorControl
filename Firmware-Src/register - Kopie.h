//- ----------------------------------------------------------------------------------------------------------------------
//- generated by createRegisterFromFile.pl
//- ID: 0x0005, File: rf_bl.xml
//- ----------------------------------------------------------------------------------------------------------------------

//- ----------------------------------------------------------------------------------------------------------------------
//- ----------------------------------------------------------------------------------------------------------------------
//                                   FW  moID   serial                         ST  devInfo
// <- 1A 01 A4 00 01 02 05 63 19 63  15  00 6C  74 6C 75 31 30 30 31 32 33 35  10  11 01 00
// FW   -> Firmware, sometimes given in xml files of hm config software
// moID -> Model ID, important for identification in hm config software
// ST   -> Subtype, identifier if device is a switch or a dimmer or a remote
// devInfo -> Device Info -> sometimes hm config files are refering on byte 23 for the amount of channels, other bytes not known
//                           23:0 0.4, means first four bit of byte 23 reflecting the amount of channels
//
//- settings of HM device for AS class -----------------------------------------------------------------------------------
const uint8_t devIdnt[] PROGMEM = {
    /* Firmware version 1 byte */  0x24,
    /* Model ID         2 byte */  0x00, 0x05,
    /* Sub Type ID      1 byte */  0x00,
    /* Device Info      3 byte */  0x41, 0x01, 0x00,
};

//- ----------------------------------------------------------------------------------------------------------------------
//- channel slice address definition -------------------------------------------------------------------------------------
const uint8_t cnlAddr[] PROGMEM = {
    0x02, 0x0a, 0x0b, 0x0c, 0x15, 0x18,
    0x0b, 0x0d, 0x0f, 0x10, 0x30, 0x57,
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0f, 0x11, 0x1c, 0x1d, 0x1e, 0x1f, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8f, 0x91, 0x9c, 0x9d, 0x9e, 0x9f,
};  // 50 byte

//- channel device list table --------------------------------------------------------------------------------------------
EE::s_cnlTbl cnlTbl[] = {
    // cnl, lst, sIdx, sLen, pAddr;
    {  0,  0, 0x00,  6,  0x000f },
    {  1,  1, 0x06,  6,  0x0015 },
    {  1,  3, 0x0c, 38,  0x001b },
    {  2,  1, 0x06,  6,  0x00ff },
    {  2,  3, 0x0c, 38,  0x0105 },
};  // 30 byte

//- peer device list table -----------------------------------------------------------------------------------------------
EE::s_peerTbl peerTbl[] = {
    // cnl, pMax, pAddr;
    {  1,  6, 0x01e9 },
    {  2,  6, 0x0201 },
};  // 8 byte

//- handover to AskSin lib -----------------------------------------------------------------------------------------------
EE::s_devDef devDef = {
    2, 5, devIdnt, cnlAddr,
};  // 10 byte

//- module registrar -----------------------------------------------------------------------------------------------------
RG::s_modTable modTbl[2];



//- ----------------------------------------------------------------------------------------------------------------------
//- only if needed -------------------------------------------------------------------------------------------------------
//- ----------------------------------------------------------------------------------------------------------------------

struct s_lst0Cnl0 {
// 0x02, 0x0a, 0x0b, 0x0c, 0x15, 0x18,
    uint8_t                           :7;       // 0x02, s:0, e:7
    uint8_t INTERNAL_KEYS_VISIBLE     :1;       // 0x02, s:7, e:8
    uint8_t Master_ID_A               :8;       // 0x0a, s:0, e:8
    uint8_t Master_ID_B               :8;       // 0x0b, s:0, e:8
    uint8_t Master_ID_C               :8;       // 0x0c, s:0, e:8
    uint8_t CONF_BUTTON_TIME          :8;       // 0x15, s:0, e:8
    uint8_t LOCAL_RESET_DISABLE       :1;       // 0x18, s:0, e:1
    uint8_t                           :7;       // 0x18, s:1, l:8
};  // 6 byte

struct s_lst1Cnl1 {
// 0x0b, 0x0d, 0x0f, 0x10, 0x30, 0x57,
    uint8_t REFERENCE_RUNNING_TIME_TOP_BOTTOM :16;       // 0x0b, s:0, e:16
    uint8_t REFERENCE_RUNNING_TIME_BOTTOM_TOP :16;       // 0x0d, s:0, e:16
    uint8_t CHANGE_OVER_DELAY         :8;       // 0x0f, s:0, e:8
    uint8_t REFERENCE_RUN_COUNTER     :8;       // 0x10, s:0, e:8
    uint8_t TRANSMIT_TRY_MAX          :8;       // 0x30, s:0, e:8
    uint8_t STATUSINFO_MINDELAY       :5;       // 0x57, s:0, e:5
    uint8_t STATUSINFO_RANDOM         :3;       // 0x57, s:5, e:8
};  // 6 byte

struct s_lst3Cnl1 {
// 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0f, 0x11, 0x1c, 0x1d, 0x1e, 0x1f, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8f, 0x91, 0x9c, 0x9d, 0x9e, 0x9f,
    uint8_t SHORT_CT_RAMPON           :4;       // 0x01, s:0, e:4
    uint8_t SHORT_CT_RAMPOFF          :4;       // 0x01, s:4, e:8
    uint8_t SHORT_CT_ONDELAY          :4;       // 0x02, s:0, e:4
    uint8_t SHORT_CT_OFFDELAY         :4;       // 0x02, s:4, e:8
    uint8_t SHORT_CT_ON               :4;       // 0x03, s:0, e:4
    uint8_t SHORT_CT_OFF              :4;       // 0x03, s:4, e:8
    uint8_t SHORT_COND_VALUE_LO       :8;       // 0x04, s:0, e:8
    uint8_t SHORT_COND_VALUE_HI       :8;       // 0x05, s:0, e:8
    uint8_t SHORT_ONDELAY_TIME        :8;       // 0x06, s:0, e:8
    uint8_t SHORT_ON_TIME             :8;       // 0x07, s:0, e:8
    uint8_t SHORT_OFFDELAY_TIME       :8;       // 0x08, s:0, e:8
    uint8_t SHORT_OFF_TIME            :8;       // 0x09, s:0, e:8
    uint8_t SHORT_ACTION_TYPE         :2;       // 0x0a, s:0, e:2
    uint8_t                           :4;       // 0x0a, s:2, e:6
    uint8_t SHORT_OFF_TIME_MODE       :1;       // 0x0a, s:6, e:7
    uint8_t SHORT_ON_TIME_MODE        :1;       // 0x0a, s:7, e:8
    uint8_t SHORT_JT_ON               :4;       // 0x0b, s:0, e:4
    uint8_t SHORT_JT_OFF              :4;       // 0x0b, s:4, e:8
    uint8_t SHORT_JT_ONDELAY          :4;       // 0x0c, s:0, e:4
    uint8_t SHORT_JT_OFFDELAY         :4;       // 0x0c, s:4, e:8
    uint8_t SHORT_JT_RAMPON           :4;       // 0x0d, s:0, e:4
    uint8_t SHORT_JT_RAMPOFF          :4;       // 0x0d, s:4, e:8
    uint8_t SHORT_OFF_LEVEL           :8;       // 0x0f, s:0, e:8
    uint8_t SHORT_ON_LEVEL            :8;       // 0x11, s:0, e:8
    uint8_t SHORT_CT_REFON            :4;       // 0x1c, s:0, e:4
    uint8_t SHORT_CT_REFOFF           :4;       // 0x1c, s:4, e:8
    uint8_t SHORT_MAX_TIME_FIRST_DIR  :8;       // 0x1d, s:0, e:8
    uint8_t SHORT_JT_REFON            :4;       // 0x1e, s:0, e:4
    uint8_t SHORT_JT_REFOFF           :4;       // 0x1e, s:4, e:8
    uint8_t SHORT_DRIVING_MODE        :8;       // 0x1f, s:0, e:8
    uint8_t LONG_CT_RAMPON            :4;       // 0x81, s:0, e:4
    uint8_t LONG_CT_RAMPOFF           :4;       // 0x81, s:4, e:8
    uint8_t LONG_CT_ONDELAY           :4;       // 0x82, s:0, e:4
    uint8_t LONG_CT_OFFDELAY          :4;       // 0x82, s:4, e:8
    uint8_t LONG_CT_ON                :4;       // 0x83, s:0, e:4
    uint8_t LONG_CT_OFF               :4;       // 0x83, s:4, e:8
    uint8_t LONG_COND_VALUE_LO        :8;       // 0x84, s:0, e:8
    uint8_t LONG_COND_VALUE_HI        :8;       // 0x85, s:0, e:8
    uint8_t LONG_ONDELAY_TIME         :8;       // 0x86, s:0, e:8
    uint8_t LONG_ON_TIME              :8;       // 0x87, s:0, e:8
    uint8_t LONG_OFFDELAY_TIME        :8;       // 0x88, s:0, e:8
    uint8_t LONG_OFF_TIME             :8;       // 0x89, s:0, e:8
    uint8_t LONG_ACTION_TYPE          :2;       // 0x8a, s:0, e:2
    uint8_t                           :3;       // 0x8a, s:2, e:5
    uint8_t LONG_MULTIEXECUTE         :1;       // 0x8a, s:5, e:6
    uint8_t LONG_OFF_TIME_MODE        :1;       // 0x8a, s:6, e:7
    uint8_t LONG_ON_TIME_MODE         :1;       // 0x8a, s:7, e:8
    uint8_t LONG_JT_ON                :4;       // 0x8b, s:0, e:4
    uint8_t LONG_JT_OFF               :4;       // 0x8b, s:4, e:8
    uint8_t LONG_JT_ONDELAY           :4;       // 0x8c, s:0, e:4
    uint8_t LONG_JT_OFFDELAY          :4;       // 0x8c, s:4, e:8
    uint8_t LONG_JT_RAMPON            :4;       // 0x8d, s:0, e:4
    uint8_t LONG_JT_RAMPOFF           :4;       // 0x8d, s:4, e:8
    uint8_t LONG_OFF_LEVEL            :8;       // 0x8f, s:0, e:8
    uint8_t LONG_ON_LEVEL             :8;       // 0x91, s:0, e:8
    uint8_t LONG_CT_REFON             :4;       // 0x9c, s:0, e:4
    uint8_t LONG_CT_REFOFF            :4;       // 0x9c, s:4, e:8
    uint8_t LONG_MAX_TIME_FIRST_DIR   :8;       // 0x9d, s:0, e:8
    uint8_t LONG_JT_REFON             :4;       // 0x9e, s:0, e:4
    uint8_t LONG_JT_REFOFF            :4;       // 0x9e, s:4, e:8
    uint8_t LONG_DRIVING_MODE         :8;       // 0x9f, s:0, e:8
};  // 38 byte

struct s_lst1Cnl2 {
// 0x0b, 0x0d, 0x0f, 0x10, 0x30, 0x57,
    uint8_t REFERENCE_RUNNING_TIME_TOP_BOTTOM :16;       // 0x0b, s:0, e:16
    uint8_t REFERENCE_RUNNING_TIME_BOTTOM_TOP :16;       // 0x0d, s:0, e:16
    uint8_t CHANGE_OVER_DELAY         :8;       // 0x0f, s:0, e:8
    uint8_t REFERENCE_RUN_COUNTER     :8;       // 0x10, s:0, e:8
    uint8_t TRANSMIT_TRY_MAX          :8;       // 0x30, s:0, e:8
    uint8_t STATUSINFO_MINDELAY       :5;       // 0x57, s:0, e:5
    uint8_t STATUSINFO_RANDOM         :3;       // 0x57, s:5, e:8
};  // 6 byte

struct s_lst3Cnl2 {
// 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0f, 0x11, 0x1c, 0x1d, 0x1e, 0x1f, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8f, 0x91, 0x9c, 0x9d, 0x9e, 0x9f,
    uint8_t SHORT_CT_RAMPON           :4;       // 0x01, s:0, e:4
    uint8_t SHORT_CT_RAMPOFF          :4;       // 0x01, s:4, e:8
    uint8_t SHORT_CT_ONDELAY          :4;       // 0x02, s:0, e:4
    uint8_t SHORT_CT_OFFDELAY         :4;       // 0x02, s:4, e:8
    uint8_t SHORT_CT_ON               :4;       // 0x03, s:0, e:4
    uint8_t SHORT_CT_OFF              :4;       // 0x03, s:4, e:8
    uint8_t SHORT_COND_VALUE_LO       :8;       // 0x04, s:0, e:8
    uint8_t SHORT_COND_VALUE_HI       :8;       // 0x05, s:0, e:8
    uint8_t SHORT_ONDELAY_TIME        :8;       // 0x06, s:0, e:8
    uint8_t SHORT_ON_TIME             :8;       // 0x07, s:0, e:8
    uint8_t SHORT_OFFDELAY_TIME       :8;       // 0x08, s:0, e:8
    uint8_t SHORT_OFF_TIME            :8;       // 0x09, s:0, e:8
    uint8_t SHORT_ACTION_TYPE         :2;       // 0x0a, s:0, e:2
    uint8_t                           :4;       // 0x0a, s:2, e:6
    uint8_t SHORT_OFF_TIME_MODE       :1;       // 0x0a, s:6, e:7
    uint8_t SHORT_ON_TIME_MODE        :1;       // 0x0a, s:7, e:8
    uint8_t SHORT_JT_ON               :4;       // 0x0b, s:0, e:4
    uint8_t SHORT_JT_OFF              :4;       // 0x0b, s:4, e:8
    uint8_t SHORT_JT_ONDELAY          :4;       // 0x0c, s:0, e:4
    uint8_t SHORT_JT_OFFDELAY         :4;       // 0x0c, s:4, e:8
    uint8_t SHORT_JT_RAMPON           :4;       // 0x0d, s:0, e:4
    uint8_t SHORT_JT_RAMPOFF          :4;       // 0x0d, s:4, e:8
    uint8_t SHORT_OFF_LEVEL           :8;       // 0x0f, s:0, e:8
    uint8_t SHORT_ON_LEVEL            :8;       // 0x11, s:0, e:8
    uint8_t SHORT_CT_REFON            :4;       // 0x1c, s:0, e:4
    uint8_t SHORT_CT_REFOFF           :4;       // 0x1c, s:4, e:8
    uint8_t SHORT_MAX_TIME_FIRST_DIR  :8;       // 0x1d, s:0, e:8
    uint8_t SHORT_JT_REFON            :4;       // 0x1e, s:0, e:4
    uint8_t SHORT_JT_REFOFF           :4;       // 0x1e, s:4, e:8
    uint8_t SHORT_DRIVING_MODE        :8;       // 0x1f, s:0, e:8
    uint8_t LONG_CT_RAMPON            :4;       // 0x81, s:0, e:4
    uint8_t LONG_CT_RAMPOFF           :4;       // 0x81, s:4, e:8
    uint8_t LONG_CT_ONDELAY           :4;       // 0x82, s:0, e:4
    uint8_t LONG_CT_OFFDELAY          :4;       // 0x82, s:4, e:8
    uint8_t LONG_CT_ON                :4;       // 0x83, s:0, e:4
    uint8_t LONG_CT_OFF               :4;       // 0x83, s:4, e:8
    uint8_t LONG_COND_VALUE_LO        :8;       // 0x84, s:0, e:8
    uint8_t LONG_COND_VALUE_HI        :8;       // 0x85, s:0, e:8
    uint8_t LONG_ONDELAY_TIME         :8;       // 0x86, s:0, e:8
    uint8_t LONG_ON_TIME              :8;       // 0x87, s:0, e:8
    uint8_t LONG_OFFDELAY_TIME        :8;       // 0x88, s:0, e:8
    uint8_t LONG_OFF_TIME             :8;       // 0x89, s:0, e:8
    uint8_t LONG_ACTION_TYPE          :2;       // 0x8a, s:0, e:2
    uint8_t                           :3;       // 0x8a, s:2, e:5
    uint8_t LONG_MULTIEXECUTE         :1;       // 0x8a, s:5, e:6
    uint8_t LONG_OFF_TIME_MODE        :1;       // 0x8a, s:6, e:7
    uint8_t LONG_ON_TIME_MODE         :1;       // 0x8a, s:7, e:8
    uint8_t LONG_JT_ON                :4;       // 0x8b, s:0, e:4
    uint8_t LONG_JT_OFF               :4;       // 0x8b, s:4, e:8
    uint8_t LONG_JT_ONDELAY           :4;       // 0x8c, s:0, e:4
    uint8_t LONG_JT_OFFDELAY          :4;       // 0x8c, s:4, e:8
    uint8_t LONG_JT_RAMPON            :4;       // 0x8d, s:0, e:4
    uint8_t LONG_JT_RAMPOFF           :4;       // 0x8d, s:4, e:8
    uint8_t LONG_OFF_LEVEL            :8;       // 0x8f, s:0, e:8
    uint8_t LONG_ON_LEVEL             :8;       // 0x91, s:0, e:8
    uint8_t LONG_CT_REFON             :4;       // 0x9c, s:0, e:4
    uint8_t LONG_CT_REFOFF            :4;       // 0x9c, s:4, e:8
    uint8_t LONG_MAX_TIME_FIRST_DIR   :8;       // 0x9d, s:0, e:8
    uint8_t LONG_JT_REFON             :4;       // 0x9e, s:0, e:4
    uint8_t LONG_JT_REFOFF            :4;       // 0x9e, s:4, e:8
    uint8_t LONG_DRIVING_MODE         :8;       // 0x9f, s:0, e:8
};